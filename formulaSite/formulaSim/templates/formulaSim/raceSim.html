{% extends "formulaSim/home.html" %}
{% load formulaSim_extras %}
{% load staticfiles %}
{% block extraLinksBlock %}

	

{% endblock extraLinksBlock %}

{% block mainContentBlock %}
	<h3> The RaceSim </h3>
	

	<form class='get-race-form' method='POST' action="{% url 'formulaSim.views.raceSim' %}" enctype="multipart/form-data">
		{% csrf_token %}
		<span>{{ errorMessage }}</span>
		<ul>
			{{the_form.as_ul}}
		</ul>
		<button type="submit" name="submit" value="Get Race">Get Race</button>
	</form>
	<div class='main-content-container'>
		<div class='race-info-container'>
		{% if race %}
			
			<div class='race-title-container'>
				<h3>{{ race.name }}</h3>
				<h4>{{ race.date }}</h4>
				<h4>Race ID: {{ race.raceid}}</h4>
			</div>
		
		{% endif %}
		{% if drivers %}
			
			{{drivers_id}}
			<ul>
				{% for driver in drivers %}
					<li><h4>{{ driver.forename }} {{ driver.surname }} {{ driver.driverid }}</h4></li>
					{% comment %}
					<ul>
						{% for lap in race.raceid|get_laptime_list:driver.driverid %}
							<li> Lap {{ lap.lap }} time: {{ lap.time }}</li>
						{% endfor %}

					</ul>
					{% endcomment %}
				{% endfor %}
			</ul>
		{% endif %}
	</div>
	<div class='canvas-container'>
		<canvas id="c" width="610" height="610" style="border:1px solid #c3c3c3;">
			Your browser does not support the HTML5 canvas tag.
		</canvas>
	</div>
</div>

	<script type="text/javascript">
		// Initial variables
		// The cnavas and its context
		var c = document.getElementById("c");
		var ctx = c.getContext("2d");

		// Grabbing the WIDTH and HEIGHT from the canvas DOM
		// Creating lists of the necessary models drivers, laps, etc
		var WIDTH = c.width;
		var HEIGHT = c.height;
		var TRACK_RADIUS = (WIDTH - 10) / 2;
		var CAR_WIDTH = 6;
   		var json_drivers = {{ serialized_drivers|safe }};
   		var json_laptimes = {{ serialized_laptimes|safe }};
   		var json_results = {{ serialized_results|safe }};
   		var json_status = {{ serialized_status|safe }};

   		var simulation_drivers = [];
   		var TOTAL_CIRCUIT_LAPS = 0;
   		var retiredDriverCount = 0;
   		var LAP_ANGLE = 0;

   		//Function to convert degrees to radians for when circles/arcs need to be drawn
   		//More of a convenience tool
   		//@param degrees
   		//@return radians conversion
   		function degToRad(deg){
   			return (Math.PI / 180 * deg);
   		}

   		


   		function FormulaDriver(lastname, driverid, result, laptimes, radiusPos){
			this.lastname = lastname;
			this.driverid = driverid;
			this.results = result;
			this.curStatus = null;
			this.laptimes = laptimes;
			this.lapLength = 0;
			this.curPosition = 0;
			this.curLap = 1;
			this.totalLapCount = this.laptimes.length;
			//this.posX = 0;
			//this.posY = startY;
			this.curSpeed = 0;
			this.retired = false;
			// Variables for the circular positioning
			this.radiusPos = radiusPos;
			this.posAngle = -90;
			this.circumSpeed = 0;
			
			this.driverCircum = (2 * Math.PI * this.radiusPos);
			

			this.updateSpeed = function(){
				// speed is based off of the laptime of the current lap
				/*
				if(!this.retired && this.laptimes[this.curLap] != null){
					this.curSpeed = (this.lapLength / this.laptimes[this.curLap].milliseconds) * 1000;
				}
				*/
				if(!this.retired && this.laptimes[this.curLap] != null){
					this.circumSpeed = ((this.driverCircum / TOTAL_CIRCUIT_LAPS) / this.laptimes[this.curLap - 1].milliseconds);
				}
			};

			this.move = function(){
				//Check if driver is retired from race
				this.check_retired();
				//If the driver has not yet retired from the race
				if(!this.retired){

					/*
					if(this.curLap == 1){
						this.curSpeed = (this.lapLength / this.laptimes[0].milliseconds) * 1000;
					}
					this.posX += this.curSpeed;
					*/
					if(this.curLap == 1){
						this.updateSpeed();
					}
					this.posAngle += (this.circumSpeed / this.driverCircum * 360) * 10000;
					this.checkLapped();
				}
				
					
				

				//else do nothing, they're retired, silly!

			};

			this.checkLapped = function(){
				//If the racer reaches the end of the track/canvas, move them to the start of the canvas
				/*
				if(this.posX >= this.lapLength * this.curLap){
					this.curLap += 1;
					this.check_retired();
					this.updateSpeed();
				}
				*/
				if(this.driverid == 3)
						console.log('LEWIS LAP COUNT:' + LAP_ANGLE);
				if(this.posAngle >= (LAP_ANGLE * this.curLap) - 90 && !this.retired){
					this.curLap += 1;
					this.check_retired();
					this.updateSpeed();
					
				}


					
			};

			this.drawRacer = function(){
				if(!this.retired){
					/*
					ctx.fillStyle = "#FFFFFF";
					ctx.beginPath();
					ctx.arc(this.posX, this.posY, 5, 0, 2 * Math.PI, true);
					ctx.fill();
					ctx.closePath();
					ctx.fillText(this.lastname + " " + this.curLap, this.posX + 25, this.posY + 8);
					*/

					ctx.beginPath();
					ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(this.posAngle), false);
					ctx.lineWidth = CAR_WIDTH;
					if(retiredDriverCount >= simulation_drivers.length - 1){
						ctx.strokeStyle = 'red';
					}
					else
						ctx.strokeStyle = 'white';
					ctx.stroke();
					ctx.closePath();
				}
				else{
					/*
					ctx.beginPath();
					ctx.fillStyle = "#FFFFFF";
					ctx.fillRect(this.posX, this.posY, 20, 10);
					ctx.fillText(this.lastname + " " + this.curStatus, this.posX - 30, this.posY + 8);
					ctx.closePath();
					*/
				}
			};
					
			this.check_retired = function(){
				if(this.curLap > this.totalLapCount && this.retired == false){
					this.retired = true;
					retiredDriverCount += 1;

					console.log("Retired drivers: " + retiredDriverCount + " number of drivers: " + simulation_drivers.length + " cur lap: " + this.curLap + " totLaps: " + this.totalLapCount + " driverid: " + this.driverid);					
				}
			};
		};


		function get_laptimes(driverid){
			var laptimeslist = []
			for(var i = 0; i < json_laptimes.length; i++){
				if(json_laptimes[i].fields.driverid == driverid)
					laptimeslist.push(json_laptimes[i].fields);
			}
			return laptimeslist;
		}

		function get_driver_results(driverid){
			for(var i = 0; i < json_results.length; i++){
				if(json_results[i].fields.driverid == driverid)
					return json_results[i];
			}
			// If there are no results, for some reason, return a null
			return null;
		}

		function set_lap_length(){
			return (WIDTH / TOTAL_CIRCUIT_LAPS);
		}

		function get_final_status(driver){
			for(var i = 0; i < json_status.length; i++){
				if(json_status[i].pk == driver.results.fields.statusid){
					if(json_status[i].pk == 1){
						//Taking advantage of access to the driver status to get the total lap count at a circuit
						//because the track model doesn't hold this information for some reason
						if(TOTAL_CIRCUIT_LAPS == 0)
							TOTAL_CIRCUIT_LAPS = driver.totalLapCount;
							LAP_ANGLE = 360 / TOTAL_CIRCUIT_LAPS;
					}
					return json_status[i].fields.status_name;
				}
			}
			return null;
		}

		// Creates all the driver  objects based on the json file given at the start
		function create_drivers(){
			for(var i = 0; i < json_drivers.length; i++){
				var driverFields = json_drivers[i].fields;
				var newDriver = new FormulaDriver(driverFields.surname, json_drivers[i].pk, get_driver_results(json_drivers[i].pk), get_laptimes(json_drivers[i].pk), TRACK_RADIUS - ( (CAR_WIDTH + 3) * (i + 1)));
				newDriver.curStatus = get_final_status( newDriver );
				newDriver.lapLength = set_lap_length();
				simulation_drivers.push( newDriver );
			}
		}

		
		

		create_drivers();

		// Checks if all drivers have retired/finished
		// if finished, return true
		// else return false
		function isRaceFinished(){
			if(retiredDriverCount >= simulation_drivers.length){
				console.log(retiredDriverCount);
				return true;
			}
			else{
				return false;	
			}
		}

   		var raceInterval = setInterval(function(){ draw() }, 1);

   		function drawCircleTrack(){
   			ctx.fillStyle = "rgba(0, 0, 0, .7)";

			ctx.beginPath();
			ctx.arc(WIDTH / 2, HEIGHT / 2, TRACK_RADIUS, 0, 2 * Math.PI, false);
			ctx.fill();

			/*
			ctx.lineWidth = 15;
			ctx.strokeStyle = 'black';
			ctx.stroke();
			*/
			ctx.closePath();
   		}

   		function draw(){
			// Clears the canvas so that old stuff doesn't remain
			ctx.clearRect(0,0, WIDTH, HEIGHT);

			drawCircleTrack();

			//Move cars and draw them
			for(var i = 0; i < simulation_drivers.length; i++){
				simulation_drivers[i].move();
				simulation_drivers[i].drawRacer();	
			}

			if(isRaceFinished()){
				console.log("FINISHED");
				draw();
				clearInterval(raceInterval);
			}
			
		}

		


		

	</script>


{% endblock mainContentBlock %}

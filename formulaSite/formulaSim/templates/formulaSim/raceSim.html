{% extends "formulaSim/home.html" %}
{% load formulaSim_extras %}
{% load staticfiles %}
{% block extraLinksBlock %}

	

{% endblock extraLinksBlock %}

{% block mainContentBlock %}	
	<div class='race-form-container'>
		<h4>Select a race</h4>
		<form class='get-race-form' method='POST' action="{% url 'formulaSim.views.raceSim' %}" enctype="multipart/form-data">
			{% csrf_token %}
			<span>{{ errorMessage }}</span>
			<ul>
				<li class='sim-form-items'>{{ the_form.year }}</li>
				<li class='sim-form-items'>{{ the_form.round }}</li>
				<li class='sim-form-items'><button class='view-race-btn' type="submit" name="submit" value="View Race">View Race</button></li>
			</ul>
		</form>
	</div>
	<div class='main-content-container'>
		
		<div class='race-info-container'>
			
			{% if race %}
				
				<div class='race-title-container'>
					<h3>{{ race.name }}</h3>
					<h4>{{ race.date }}</h4>
				</div>
			
			{% endif %}
			

			{% if drivers %}
				{{drivers_id}}
				<ul class='drivers-list' id='Drivers_List'>
					{% for driver in drivers %}
						<li>
							<span id='Driver_Color_Legend' class='driver-colors'></span>
							<h4>{{ driver.forename }} {{ driver.surname }}</h4>
							<br>
							<span id='Driver_Status_Legend' class='driver-status'></span>
						</li>
					{% endfor %}
				</ul>
			{% endif %}
		</div>

		<div class='canvas-container'>

			{% if begin_simulation %}
				<div class='slider-holder'>
					<label for=fader>Simulation Speed</label>
					<input type=range min=1 max=10000 value=5000 id='sim-speed-slider' oninput="outputUpdate(value)">

					<output for=fader id='speed'>5000</output>
					<script >
						function outputUpdate(speed) {
							document.querySelector('#speed').value = speed;
						}

					</script>
				</div>	
			{% endif %}

			<canvas id="c" width="740" height="740">
				Your browser does not support the HTML5 canvas.
			</canvas>
		</div>
	</div>
	{% if begin_simulation %}
		<script type="text/javascript">
			// Initial variables
			// The cnavas and its context
			var c = document.getElementById("c");
			var ctx = c.getContext("2d");

			// List of color variables for racers to choose from
			var driverColorSpectrum = ['#F8C677', '#5F7BB7', '#F34A35', '#B81C46', '#2DD692', '#F9E671', '#FFAC43', 
			'#F36B76', 
			'#FF005C', '#2DA570', '#FEBE18', '#FF6B00', '#F35260', '#FC000F', '#2DD070', '#7F89AE', '#F3427F', '#FF8943', 
			'#FF6600', '#E91229', '#FFA300', '#00A9B5', '#7512A7', '#2D6F70', '#D93445'
			];

			// Grabbing the WIDTH and HEIGHT from the canvas DOM
			// Creating lists of the necessary models drivers, laps, etc
			var WIDTH = c.width;
			var HEIGHT = c.height;
			var TRACK_RADIUS = (WIDTH - 35) / 2;
			var CAR_WIDTH = 10;
	   		var json_drivers = {{ serialized_drivers|safe }};
	   		var json_laptimes = {{ serialized_laptimes|safe }};
	   		var json_results = {{ serialized_results|safe }};
	   		var json_status = {{ serialized_status|safe }};
	   		var json_pitstops = {{ serialized_pitstops|safe }};
	   		var simulation_drivers = [];
	   		var TOTAL_CIRCUIT_LAPS = 0;
	   		var retiredDriverCount = 0;
	   		var LAP_ANGLE = 0;

	   		//Function to convert degrees to radians for when circles/arcs need to be drawn
	   		//More of a convenience tool
	   		//@param degrees
	   		//@return radians conversion
	   		function degToRad(deg){
	   			return (Math.PI / 180 * deg);
	   		}

	   	
	   		function FormulaDriver(lastname, codeName, driverid, result, laptimes, pitstops, radiusPos){
				this.lastname = lastname;
				this.codeName = codeName
				this.driverid = driverid;
				this.results = result;
				this.pitstops = pitstops;
				this.curStatus = null;
				this.laptimes = laptimes;
				this.lapLength = 0;
				this.curPosition = 0;
				this.curLap = 1;
				this.totalLapCount = this.laptimes.length;
				//this.posX = 0;
				//this.posY = startY;
				this.curSpeed = 0;
				this.retired = false;
				// Variables for the circular positioning
				this.radiusPos = radiusPos;
				this.posAngle = -90;
				this.circumSpeed = 0;
				this.driverCircum = (2 * Math.PI * this.radiusPos);

				// color variable for driver
				this.driverColor = 'rgb(0, 0, 0)';
				this.driverStatsSpan = null;
				this.pitstop_laps_draw = [];

				this.updateSpeed = function(){
					// speed is based off of the laptime of the current lap
					/*
					if(!this.retired && this.laptimes[this.curLap] != null){
						this.curSpeed = (this.lapLength / this.laptimes[this.curLap].milliseconds) * 1000;
					}
					*/
					if(!this.retired && this.laptimes[this.curLap] != null){
						this.circumSpeed = ((this.driverCircum / TOTAL_CIRCUIT_LAPS) / this.laptimes[this.curLap - 1].milliseconds);
					}
				};

				this.move = function(){
					//Check if driver is retired from race
					this.check_retired();


					//If the driver has not yet retired from the race
					if(!this.retired){
						if(this.curLap == 1){
							this.updateSpeed();
						}
						var speedBoost = document.querySelector('#sim-speed-slider').value;
						this.posAngle += (this.circumSpeed / this.driverCircum * 360) * speedBoost;
						this.checkLapped();

					}
					//else do nothing, they're retired, silly!

				};

				this.drawPitstops = function(){
					for(var i = 0; i < this.pitstop_laps_draw.length; i++){
						lap = this.pitstop_laps_draw[i];
						var x = WIDTH/2 + (this.radiusPos) * Math.cos( degToRad(( -90 + (lap * LAP_ANGLE - (LAP_ANGLE / 2)) )) );
						var y = HEIGHT/2 + (this.radiusPos) * Math.sin(degToRad(( -90 + (lap * LAP_ANGLE - (LAP_ANGLE / 2)) )));

						ctx.beginPath();
						ctx.fillStyle = this.driverColor;
						ctx.arc(x, y, (CAR_WIDTH / 2) + 1, 0, 2 * Math.PI, false);
						ctx.fill();
						ctx.lineWidth = 0.5;
					    ctx.strokeStyle = 'black';
					    ctx.stroke();
						ctx.fillStyle = '#FAFAFA';
						ctx.textAlign = 'center';
						ctx.font = ' 8px Helvetica';
						ctx.fillText('P', x, y + 3);
						ctx.closePath();
					}
				};

				this.checkPitted = function(){
					for(var i = 0; i < this.pitstops.length; i++){
						if(pitstops[i].lap == (this.curLap - 1)){
							this.pitstop_laps_draw.push(this.curLap - 1);
						}
					}
				};

				this.checkLapped = function(){
					//If the racer reaches the end of the track/canvas, move them to the start of the canvas
					
					if(this.posAngle >= (LAP_ANGLE * this.curLap) - 90 && !this.retired){
						this.checkPitted();
						this.curLap += 1;
						this.check_retired();
						this.updateSpeed();	

					}	
				};

				this.drawRacerHead = function(){
					var x = WIDTH/2 + (this.radiusPos) * Math.cos(degToRad((this.posAngle)));
					var y = HEIGHT/2 + (this.radiusPos) * Math.sin(degToRad((this.posAngle)));
					

					ctx.beginPath();
					ctx.fillStyle = "#FAFAFA";
					ctx.arc(x, y, (CAR_WIDTH / 2) + 1, 0, 2 * Math.PI, false);
					ctx.fill();
					ctx.closePath();
				};

				this.drawFinalPostion = function(){
					var x = WIDTH/2 + (this.radiusPos) * Math.cos(degToRad((this.posAngle)));
					var y = HEIGHT/2 + (this.radiusPos) * Math.sin(degToRad((this.posAngle)));
					ctx.beginPath();
					ctx.fillStyle = 'black';
					ctx.textAlign = 'center';
					ctx.font = ' 8px Helvetica';
					ctx.fillText(this.results.fields.positiontext, x, y + 3);
					ctx.closePath();
				};

				this.drawRacer = function(){
					if(!this.retired){

						ctx.beginPath();
						ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(this.posAngle), false);
						ctx.lineWidth = CAR_WIDTH;
						ctx.strokeStyle = this.driverColor;
						ctx.stroke();
						ctx.closePath();
						this.drawRacerHead();
						this.drawPitstops();
						
					}
					else{

						ctx.beginPath();
						// if the driver retires immediately, then display an arc that is halfway
						// through the lap to better show the arc and its color
						if(this.totalLapCount == 0)
							ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(-87), false);
						else
							ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(this.posAngle), false);
						ctx.lineWidth = CAR_WIDTH;
						//ctx.strokeStyle = this.driverColor;
						ctx.strokeStyle = this.driverColor;
						ctx.stroke();
						ctx.closePath();
						this.drawRacerHead();
						this.drawFinalPostion();
						this.checkPitted();
						this.drawPitstops();
					}
				};
						
				this.check_retired = function(){
					if(this.curLap > this.totalLapCount && this.retired == false){
						this.retired = true;
						retiredDriverCount += 1;
						this.driverStatsSpan.innerHTML = this.curStatus + " Pos: " + this.results.fields.positiontext;
						console.log(this.pitstops);
					}
				};
			};


			function get_laptimes(driverid){
				var laptimeslist = [];
				for(var i = 0; i < json_laptimes.length; i++){
					if(json_laptimes[i].fields.driverid == driverid)
						laptimeslist.push(json_laptimes[i].fields);
				}
				return laptimeslist;
			}

			function get_driver_results(driverid){
				for(var i = 0; i < json_results.length; i++){
					if(json_results[i].fields.driverid == driverid)
						return json_results[i];
				}
				// If there are no results, for some reason, return a null
				return null;
			}

			function get_pitstops(driverid){
				var pitstoplist = [];

				for(var i = 0; i < json_pitstops.length; i++){
					if(json_pitstops[i].fields.driverid == driverid){
						pitstoplist.push(json_pitstops[i].fields);
					}
				}
				console.log(pitstoplist);
				return pitstoplist;
			}

			function set_lap_length(){
				return (WIDTH / TOTAL_CIRCUIT_LAPS);
			}


			function get_final_status(driver){
				for(var i = 0; i < json_status.length; i++){
					if(json_status[i].pk == driver.results.fields.statusid){
						if(json_status[i].pk == 1){
							//Taking advantage of access to the driver status to get the total lap count at a circuit
							//because the track model doesn't hold this information for some reason
							if(TOTAL_CIRCUIT_LAPS == 0){
								TOTAL_CIRCUIT_LAPS = driver.totalLapCount;
								LAP_ANGLE = 360 / TOTAL_CIRCUIT_LAPS;
							}
						}
						return json_status[i].fields.status_name;
					}
				}
				return null;
			}

			function set_driver_color(){
				var r = Math.floor(Math.random() * (255));
				var g = Math.floor(Math.random() * (255 - 100) + 100);
				var b = Math.floor(255);
				return 'rgb(' + r + ', ' + g + ', ' + b + ')';
			}


			// Creates all the driver  objects based on the json file given at the start
			function create_drivers(){
				for(var i = 0; i < json_drivers.length; i++){
					var driverFields = json_drivers[i].fields;
					var newDriver = new FormulaDriver(driverFields.surname, driverFields.code, json_drivers[i].pk, get_driver_results(json_drivers[i].pk), get_laptimes(json_drivers[i].pk), get_pitstops(json_drivers[i].pk), (TRACK_RADIUS * 0.98) - ((CAR_WIDTH + 3)*(i + 1)));
					newDriver.curStatus = get_final_status( newDriver );
					newDriver.lapLength = set_lap_length();
					//newDriver.driverColor = set_driver_color();
					newDriver.driverColor = driverColorSpectrum[i];
					document.getElementById('Drivers_List').querySelector('#Driver_Color_Legend').id = newDriver.codeName;
					document.getElementById(newDriver.codeName).style.background = newDriver.driverColor;
					document.getElementById('Drivers_List').querySelector('#Driver_Status_Legend').id = newDriver.codeName + "_Status";
					newDriver.driverStatsSpan = document.getElementById(newDriver.codeName + "_Status");

					//simulation_drivers[newDriver.results.fields.grid - 1] = newDriver;
					simulation_drivers.push( newDriver );
					
				}
				//simulation_drivers = orderOnGridPos(simulation_drivers);
			}

			
			// Checks if all drivers have retired/finished
			// if finished, return true
			// else return false
			function isRaceFinished(){
				if(retiredDriverCount >= simulation_drivers.length){
					return true;
				}
				else{
					return false;	
				}
			}

	   		

	   		function drawCircleTrack(){
	   			ctx.fillStyle = "rgba(82, 82, 82, .1)";

				ctx.beginPath();
				ctx.arc(WIDTH / 2, HEIGHT / 2, TRACK_RADIUS, 0, 2 * Math.PI, false);
				ctx.fill();
				ctx.closePath();
	   		}

	   		function drawLapLines(){
	   			for(var i = 0; i < TOTAL_CIRCUIT_LAPS; i++){
		   			var x = WIDTH/2 + (TRACK_RADIUS + 10) * Math.cos(degToRad(-90 + (LAP_ANGLE * i)));
					var y = HEIGHT/2 + (TRACK_RADIUS + 10) * Math.sin(degToRad(-90 + (LAP_ANGLE * i)));
					ctx.beginPath();              
					ctx.lineWidth = 1;
					ctx.strokeStyle = "#6D6E63";  
					ctx.moveTo(WIDTH / 2, HEIGHT / 2);
					ctx.lineTo(x, y);
					ctx.stroke();  
					
					ctx.fillStyle = '#FAFAFA';
					ctx.textAlign = 'center';
					ctx.font = ' 12px Helvetica';
					ctx.fillText(i + 1, x, y + 5);
					ctx.closePath();
				}
	   		}


	   		// Var to hold animation ID so that it can be cancelled when simulation
	   		// is complete or paused
	   		var animationID;
	   		var raceInterval = null;
	   		function draw(){
				// Clears the canvas so that old stuff doesn't remain
				ctx.clearRect(0,0, WIDTH, HEIGHT);

				drawCircleTrack();
				drawLapLines();

				//Move cars and draw them
				for(var i = 0; i < simulation_drivers.length; i++){
					//simulation_drivers[i].move();
					simulation_drivers[i].drawRacer();	
				}
				animationID = requestAnimationFrame(draw);
				if(isRaceFinished()){
					window.cancelAnimationFrame(animationID);
					clearInterval(raceInterval);
				}
				
			}

			function simulate(){
				for(var i = 0; i < simulation_drivers.length; i++){
					simulation_drivers[i].move();
					//simulation_drivers[i].drawRacer();	
				}
			}

			
			window.onload = function(){
				//Creates drivers for simulation
				create_drivers();

				window.requestAnimationFrame(draw);
				raceInterval = setInterval(function(){simulate();}, 1);
				
			}

		</script>
	{% endif %}


{% endblock mainContentBlock %}

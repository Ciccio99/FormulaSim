{% extends "formulaSim/home.html" %}
{% load formulaSim_extras %}
{% load staticfiles %}
{% block extraLinksBlock %}

	

{% endblock extraLinksBlock %}

{% block mainContentBlock %}	
	<div class='background-image'>
	<div class='semi-transparent-div'>
		
		
		<div class='main-content-container'>
			
			<div class='race-info-container'>
				<div class='race-form-container'>
					<form class='get-race-form' method='POST' action="{% url 'formulaSim.views.raceSim' %}" enctype="multipart/form-data">
						{% csrf_token %}
						
						<ul>
							<li class='sim-form-items'>{{ the_form.selectRace }}</li>
							<li class='sim-form-items'>
								<button class='view-race-btn btn-transitions' type="submit" name="submit" value="Load Race">Load Race</button>
							</li>
						</ul>
						<span class='form-error-message'>{{ errorMessage }}</span>
					</form>
				</div>
				{% if begin_simulation %}
					{% if race %}
						<div class='race-title-container'>
							<span class='race-title'>{{ race.name }}</span>
							<span class='race-location'>{{ circuit.location }}, {{ circuit.country }}</span>
							<span class='race-date'>{{ race.date }}</span>
						</div>
					
					{% endif %}
					

					{% if drivers %}
						{{drivers_id}}
						<ul class='drivers-list' id='Drivers_List'>
							{% for driver in drivers %}
								<li>
									<span id='Driver_Color_Legend' class='driver-colors'></span>
									<h4>{{ driver.forename }} {{ driver.surname }}</h4>
									<br>
									<span id='Driver_Status_Legend' class='driver-status'></span>
								</li>
							{% endfor %}
						</ul>
					{% endif %}
			</div>
				{% endif %}
				{% if begin_simulation %}
				<div class='canvas-container'>	
						<div class='slider-holder'>
							<label class='slider-title' for=fader>Simulation Speed</label>
							<button id='Start_Pause_Btn' class='simulation-btns btn-transitions' type="button" name="button" value="Start" onclick='startSimulation()'>Start</button>
							<div class='slider-inner-div'>
								<span class='slider-labels'>Slow</span>
								<input type=range min=1 max=10000 value=1000 id='sim-speed-slider'>
								<span class='slider-labels'>Fast</span>
							</div>
							<button class='simulation-btns btn-transitions' type="button" name="button" value="Restart" onclick='restartSimulation()'>Restart</button>
						</div>	
					<canvas id="c" width="700" height="700">
						Your browser does not support the HTML5 canvas.
					</canvas>
				{% endif %}
			</div>
		</div>
		
	</div>
	</div>
	{% if begin_simulation %}
		<script type="text/javascript">
			// Initial variables
			// The cnavas and its context
			var c = document.getElementById("c");
			var ctx = c.getContext("2d");

			// List of color variables for racers to choose from
			var driverColorSpectrum = ['#F8C677', '#5F7BB7', '#F34A35', '#B81C46', '#2DD692', '#F9E671', '#FFAC43', 
			'#F36B76', '#FF005C', '#2DA570', '#FEBE18', '#FF6B00', '#D93445', '#FC000F', '#2DD070', '#7F89AE', '#F3427F', 
			'#FF8943', '#FF6600', '#E91229', '#FFA300', '#00A9B5', '#7512A7', '#2D6F70', '#F35260'
			];

			// Grabbing the WIDTH and HEIGHT from the canvas DOM
			
			var WIDTH = c.width;
			var HEIGHT = c.height;
			// Creating lists of the necessary models drivers, laps, etc
	   		var json_drivers = {{ serialized_drivers|safe }};
	   		var json_laptimes = {{ serialized_laptimes|safe }};
	   		var json_results = {{ serialized_results|safe }};
	   		var json_status = {{ serialized_status|safe }};
	   		var json_pitstops = {{ serialized_pitstops|safe }};

	   		// Variables for the simulation
	   		
	   		var TRACK_RADIUS = (WIDTH - 35) / 2;
			var CAR_WIDTH = 9;
	   		var TOTAL_CIRCUIT_LAPS = 0;
	   		var LAP_ANGLE = 0;

	   		var simulation_drivers = [];
	   		var retiredDriverCount = 0;
	   		var simulationCompleted = true;
	   		var simulationPaused = false;

	   		//Function to convert degrees to radians for when circles/arcs need to be drawn
	   		//More of a convenience tool
	   		//@param degrees
	   		//@return radians conversion
	   		function degToRad(deg){
	   			return (Math.PI / 180 * deg);
	   		}

	   	
	   		function FormulaDriver(lastname, codeName, driverid, result, laptimes, pitstops){
				this.lastname = lastname;
				this.codeName = codeName
				this.driverid = driverid;
				this.results = result;
				this.pitstops = pitstops;
				this.curStatus = null;
				this.laptimes = laptimes;
				this.lapLength = 0;
				this.curPosition = 0;
				this.curLap = 1;
				this.totalLapCount = this.laptimes.length;
				//this.posX = 0;
				//this.posY = startY;
				this.curSpeed = 0;
				this.retired = false;
				// Variables for the circular positioning
				this.radiusPos = 0;
				this.posAngle = -90;
				this.circumSpeed = 0;
				this.driverCircum = (2 * Math.PI * this.radiusPos);

				// color variable for driver
				this.driverColor = 'rgb(0, 0, 0)';
				this.driverStatsSpan = null;
				this.pitstop_laps_draw = [];

				this.updateSpeed = function(){
					// speed is based off of the laptime of the current lap
					/*
					if(!this.retired && this.laptimes[this.curLap] != null){
						this.curSpeed = (this.lapLength / this.laptimes[this.curLap].milliseconds) * 1000;
					}
					*/
					if(!this.retired && this.laptimes[this.curLap - 1] != null){
						this.circumSpeed = ((this.driverCircum / TOTAL_CIRCUIT_LAPS) / this.laptimes[this.curLap - 1].milliseconds);
					}
				};

				this.move = function(){
					//Check if driver is retired from race
					this.check_retired();


					//If the driver has not yet retired from the race
					if(!this.retired){
						if(this.curLap == 1){
							this.updateSpeed();
						}
						var speedBoost = document.querySelector('#sim-speed-slider').value;
						this.posAngle += (this.circumSpeed / this.driverCircum * 360) * speedBoost;
						this.checkLapped();

					}
					//else do nothing, they're retired, silly!

				};

				this.drawPitstops = function(){
					for(var i = 0; i < this.pitstop_laps_draw.length; i++){
						lap = this.pitstop_laps_draw[i];
						var x = WIDTH/2 + (this.radiusPos) * Math.cos( degToRad(( -90 + (lap * LAP_ANGLE - (LAP_ANGLE / 2)) )) );
						var y = HEIGHT/2 + (this.radiusPos) * Math.sin(degToRad(( -90 + (lap * LAP_ANGLE - (LAP_ANGLE / 2)) )));

						ctx.beginPath();
						ctx.fillStyle = this.driverColor;
						ctx.arc(x, y, (CAR_WIDTH / 2) + 1, 0, 2 * Math.PI, false);
						ctx.fill();
						ctx.lineWidth = 0.5;
					    ctx.strokeStyle = 'black';
					    ctx.stroke();
						ctx.fillStyle = '#FAFAFA';
						ctx.textAlign = 'center';
						ctx.font = ' 8px Helvetica';
						ctx.fillText('P', x, y + 3);
						ctx.closePath();
					}
				};

				this.checkPitted = function(){
					for(var i = 0; i < this.pitstops.length; i++){
						if(pitstops[i].lap == (this.curLap - 1)){
							this.pitstop_laps_draw.push(this.curLap - 1);
						}
					}
				};

				this.checkLapped = function(){
					//If the racer reaches the end of the track/canvas, move them to the start of the canvas
					if(this.posAngle >= (LAP_ANGLE * this.curLap) - 90 && !this.retired){
						this.curLap += 1;
						this.checkPitted();
						this.check_retired();
						this.updateSpeed();	
					}	
				};

				this.drawRacerHead = function(){
					var x = WIDTH/2 + (this.radiusPos) * Math.cos(degToRad((this.posAngle)));
					var y = HEIGHT/2 + (this.radiusPos) * Math.sin(degToRad((this.posAngle)));
					

					ctx.beginPath();
					ctx.fillStyle = "#FAFAFA";
					ctx.arc(x, y, (CAR_WIDTH / 2) + 1, 0, 2 * Math.PI, false);
					ctx.fill();
					ctx.closePath();
				};

				this.drawFinalPostion = function(){
					var x = WIDTH/2 + (this.radiusPos) * Math.cos(degToRad((this.posAngle)));
					var y = HEIGHT/2 + (this.radiusPos) * Math.sin(degToRad((this.posAngle)));
					ctx.beginPath();
					ctx.fillStyle = 'black';
					ctx.textAlign = 'center';
					ctx.font = ' 8px Helvetica';
					ctx.fillText(this.results.fields.positiontext, x, y + 3);
					ctx.closePath();
				};

				this.drawRacer = function(){
					if(!this.retired){

						ctx.beginPath();
						ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(this.posAngle), false);
						ctx.lineWidth = CAR_WIDTH;
						ctx.strokeStyle = this.driverColor;
						ctx.stroke();
						ctx.closePath();
						this.drawPitstops();
						this.drawRacerHead();
					}
					else{

						ctx.beginPath();
						// if the driver retires immediately, then display an arc that is halfway
						// through the lap to better show the arc and its color
						if(this.totalLapCount == 0)
							ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(-87), false);
						else
							ctx.arc(WIDTH / 2, HEIGHT / 2, this.radiusPos, degToRad(-90), degToRad(this.posAngle), false);
						ctx.lineWidth = CAR_WIDTH;
						//ctx.strokeStyle = this.driverColor;
						ctx.strokeStyle = this.driverColor;
						ctx.stroke();
						ctx.closePath();
						this.drawPitstops();
						this.drawRacerHead();
						this.drawFinalPostion();
					}
				};
						
				this.check_retired = function(){
					if(this.curLap > this.totalLapCount && this.retired == false){
						this.retired = true;
						retiredDriverCount += 1;
						this.driverStatsSpan.innerHTML = this.curStatus + " Pos: " + this.results.fields.positiontext;
					}
				};
			};


			function get_laptimes(driverid){
				var laptimeslist = [];
				for(var i = 0; i < json_laptimes.length; i++){
					if(json_laptimes[i].fields.driverid == driverid)
						laptimeslist.push(json_laptimes[i].fields);
				}
				return laptimeslist;
			}

			function get_driver_results(driverid){
				for(var i = 0; i < json_results.length; i++){
					if(json_results[i].fields.driverid == driverid)
						return json_results[i];
				}
				// If there are no results, for some reason, return a null
				return null;
			}

			function get_pitstops(driverid){
				var pitstoplist = [];

				for(var i = 0; i < json_pitstops.length; i++){
					if(json_pitstops[i].fields.driverid == driverid){
						pitstoplist.push(json_pitstops[i].fields);
					}
				}
				return pitstoplist;
			}

			function set_lap_length(){
				return (WIDTH / TOTAL_CIRCUIT_LAPS);
			}


			function get_final_status(driver){
				for(var i = 0; i < json_status.length; i++){
					if(json_status[i].pk == driver.results.fields.statusid){
						if(json_status[i].pk == 1){
							//Taking advantage of access to the driver status to get the total lap count at a circuit
							//because the track model doesn't hold this information for some reason
							if(TOTAL_CIRCUIT_LAPS == 0){
								TOTAL_CIRCUIT_LAPS = driver.totalLapCount;
								LAP_ANGLE = 360 / TOTAL_CIRCUIT_LAPS;
							}
						}
						return json_status[i].fields.status_name;
					}
				}
				return null;
			}

			function set_driver_color(){
				var r = Math.floor(Math.random() * (255));
				var g = Math.floor(Math.random() * (255 - 100) + 100);
				var b = Math.floor(255);
				return 'rgb(' + r + ', ' + g + ', ' + b + ')';
			}


			// Creates all the driver  objects based on the json file given at the start
			function create_drivers(){
				for(var i = 0; i < json_drivers.length; i++){
					var driverFields = json_drivers[i].fields;
					var newDriver = new FormulaDriver(driverFields.surname, driverFields.code, json_drivers[i].pk, get_driver_results(json_drivers[i].pk), get_laptimes(json_drivers[i].pk), get_pitstops(json_drivers[i].pk));
					newDriver.radiusPos = (TRACK_RADIUS * 0.99) - ((CAR_WIDTH + 4)*(i + 1));
					newDriver.driverCircum = (2 * Math.PI * newDriver.radiusPos);
					newDriver.curStatus = get_final_status( newDriver );
					newDriver.lapLength = set_lap_length();
					//newDriver.driverColor = set_driver_color();
					newDriver.driverColor = driverColorSpectrum[i];
					if(document.getElementById(newDriver.codeName) == null){
						document.getElementById('Drivers_List').querySelector('#Driver_Color_Legend').id = newDriver.codeName;
						document.getElementById(newDriver.codeName).style.background = newDriver.driverColor;
						document.getElementById('Drivers_List').querySelector('#Driver_Status_Legend').id = newDriver.codeName + "_Status";
					}
					newDriver.driverStatsSpan = document.getElementById(newDriver.codeName + "_Status");
					simulation_drivers.push( newDriver );
					
				}
				//simulation_drivers = orderOnGridPos(simulation_drivers);
			}

			
			// Checks if all drivers have retired/finished
			// if finished, return true
			// else return false
			function isRaceFinished(){
				if(retiredDriverCount >= simulation_drivers.length){
					simulationCompleted = true;
					return true;
				}
				else{
					return false;	
				}
			}

	   		

	   		function drawCircleTrack(){
	   			ctx.fillStyle = "rgba(82, 82, 82, .1)";

				ctx.beginPath();
				ctx.arc(WIDTH / 2, HEIGHT / 2, TRACK_RADIUS, 0, 2 * Math.PI, false);
				ctx.fill();
				ctx.closePath();
	   		}

	   		function drawLapLines(){
	   			for(var i = 0; i < TOTAL_CIRCUIT_LAPS; i++){
		   			var x = WIDTH/2 + (TRACK_RADIUS + 10) * Math.cos(degToRad(-90 + (LAP_ANGLE * i)));
					var y = HEIGHT/2 + (TRACK_RADIUS + 10) * Math.sin(degToRad(-90 + (LAP_ANGLE * i)));
					ctx.beginPath();              
					ctx.lineWidth = 1;
					ctx.strokeStyle = "#6D6E63";  
					ctx.moveTo(WIDTH / 2, HEIGHT / 2);
					ctx.lineTo(x, y);
					ctx.stroke();  
					
					ctx.fillStyle = '#FAFAFA';
					ctx.textAlign = 'center';
					ctx.font = ' 12px Helvetica';
					ctx.fillText(i + 1, x, y + 5);
					ctx.closePath();
				}
	   		}

	   		function drawCheckeredLine(){
	   			for(var i = 0; i < TRACK_RADIUS; i+=3){
	   				ctx.beginPath();
	   				if( i % 2 == 0){
		   				ctx.fillStyle = '#fafafa';
		   				ctx.fillRect(WIDTH/2 - 2, HEIGHT/2 - i, 2,3);
		   				ctx.fillStyle = 'black';
		   				ctx.fillRect(WIDTH/2, HEIGHT/2 - i, 2,3);
		   			}
		   			else{
		   				ctx.fillStyle = 'black';
		   				ctx.fillRect(WIDTH/2 - 2, HEIGHT/2 - i, 2,3);
		   				ctx.fillStyle = '#FAFAFA';
		   				ctx.fillRect(WIDTH/2, HEIGHT/2 - i, 2,3);
		   			}
	   				ctx.closePath();
	   			}
	   		}


	   		// Var to hold animation ID so that it can be cancelled when simulation
	   		// is complete or paused
	   		var animationID = null;
	   		var raceInterval = null;

	   		function draw(){
				// Clears the canvas so that old stuff doesn't remain
				ctx.clearRect(0,0, WIDTH, HEIGHT);

				// Draws the background track
				drawCircleTrack();

				// Draws the track lap lines
				drawLapLines();
				drawCheckeredLine();
				

				// Loop through drivers to draw them
				for(var i = 0; i < simulation_drivers.length; i++){
					simulation_drivers[i].drawRacer();	
				}

				// Checks to see if the racr is finished, if so stop all animations
				// and calculations
				if(isRaceFinished()){
					window.cancelAnimationFrame(animationID);
					clearInterval(raceInterval);
				}
				else{
					animationID = requestAnimationFrame(draw);
				}
				
			}

			// Move logic loop
			function simulate(){
				for(var i = 0; i < simulation_drivers.length; i++){
					simulation_drivers[i].move();
				}
			}

			
			function startSimulation(){
				//Creates drivers for simulation
				if(simulationCompleted){
					simulationCompleted = false;
					simulationPaused = false;
					if(simulation_drivers.length == 0)
						create_drivers();
					animationID = window.requestAnimationFrame(draw);
					raceInterval = setInterval(function(){simulate();}, 1);
					document.getElementById('Start_Pause_Btn').innerHTML = 'Pause';
				}
				else if(simulationPaused){
					//Resume if paused
					simulationPaused = false;
					animationID = window.requestAnimationFrame(draw);
					raceInterval = setInterval(function(){simulate();}, 1);
					document.getElementById('Start_Pause_Btn').innerHTML = 'Pause';

				}	
				else{
					pauseSimulation();
				}
			}

			function pauseSimulation(){
				if(animationID != null || raceInterval != null){
					simulationPaused = true;
					window.cancelAnimationFrame(animationID);
					clearInterval(raceInterval);
					animationID = null;
					raceInterval = null;
					document.getElementById('Start_Pause_Btn').innerHTML = 'Resume';

				}
			}

			
			function restartSimulation(){
				//Stop simulation and animation loops
				simulationCompleted = true;
				simulationPaused = false;
				
					window.cancelAnimationFrame(animationID);
					clearInterval(raceInterval);
				
				//Clear the canvas
				ctx.clearRect(0,0, WIDTH, HEIGHT);
				//Clearing status text from relavent DOM elements
				list = document.getElementsByClassName("driver-status");
				for(var i = 0; i < list.length; i++){
					list[i].innerHTML = "";
				}

				//Clear Drivers list
				simulation_drivers.length = 0;
				retiredDriverCount = 0;
				//Restart
				startSimulation();
			}

			create_drivers();
			drawCircleTrack();
			drawLapLines();

		</script>
	{% endif %}


{% endblock mainContentBlock %}
